; FLOATING POINT ROUTINES FOR THE 6809

; I recently found these files on an old CD-R. They are intended to be
; used with the sbc09 system. These routines should be fairly portable
; to any 6809-based system

; Originally published on https://lennartb.home.xs4all.nl/m6809.html
; Adapted by Marco Spedaletti

; FLOATING POINT PRIMITIVES.

INTBUF		RZB 4		;BUFFER TO STORE INTEGER.
INTBUF2		RZB 4
BCDBUF		RZB 5		;BUFFER FOR BCD CONVERSION.

ENDSTR		RZB 2		;END ADDRESS OF STRING.
DPL		    RZB 1		;DECIMAL POINT LOCATION.

; U IS THE FLOATING POINT STACK POINTER AND POINTS TO THE FIRST FREE
; LOCATION. EACH NUMBER OCCUPIES 5 BYTES, 
; FORMAT: BYTE0: BINARY EXPONENT  $00-$FF $80 MEANS NUMBER IN RANGE 1..2.
;         BYTE1-BYTE4 BINARY FRACTION BETWEEN 1.0 AND 2.0, MSB WOULD
;      	  ALWAYS BE SET, BUT REPLACED BY SIGN.
;	        SPECIAL CASE: ALL BYTES ZERO, NUMBER=0.

FPSPAREA	RZB	  5*32

; EXCHANGE TOP TWO NUMBERS ON STACK.
FPEXG		
    LDX -2,U
		LDD -7,U
		STX -7,U
		STD -2,U
		LDX -4,U
		LDD -9,U
		STX -9,U
		STD -4,U
		LDA -5,U
		LDB -10,U
		STA -10,U
		STB -5,U
		RTS

FPDUP		
    LEAX -5,U
; LOAD FP NUMBER FROM ADDRESS X AND PUSH ONTO STACK.
FPLOD		
    LDD ,X++
		STD ,U++
		LDD ,X++
		STD ,U++
		LDA ,X+
		STA ,U+

FCKMEM		
    ; TFR S,D
		; STU FPSP
		; SUBD FPSP
		; SUBD #40	
		; LBCS MAKEFREE	;TEST FOR SUFFICIENT FREE SPACE.
		RTS 
		
; POP FP NUMBER FROM STACK AND STORE INTO ADDRESS X.
FPSTO		
    LDA -5,U
		STA ,X+
		LDD -4,U
		STD ,X++
		LDD -2,U
		STD ,X++
		LEAU -5,U
		RTS

; COMPARE MAGNITUDE (SECOND-TOP).
FPCMPMAG	
    LDA -10,U
		CMPA -5,U	;COMPARE EXPONENTS.
		BNE CMPEND
		LDD -4,U
		ANDA #$7F	;ELIMINATE SIGN BIT.
		STD ,--S
		LDD -9,U
		ANDA #$7F	;ELIMINATE SIGN BIT.
		SUBD ,S++	;COMPARE MSB OF MANTISSA.
		BNE CMPEND
		LDD -7,U
		SUBD -2,U
		BNE CMPEND
CMPEND		
    RTS

; TEST A TOP NUMBER FOR 0.
FPTEST0
    TST -5,U
		BNE CMPEND
		LDD -4,U
		BNE CMPEND
		LDD -2,U
		RTS

; FLOATING POINT SUBTRACTION.
FPSUB		
    JSR FPNEG

; FLOATING POINT ADDITION.
FPADD		
    BSR FPCMPMAG	;FIRST COMPARE MAGNITUDES.
		BCC FPADD1
		JSR FPEXG	;PUT THE BIGGEST ONE SECOND.
FPADD1		
    BSR FPTEST0		
		BEQ FPADDEND	;DONE IF SMALLEST NUMBER IS 0.
		LDA -10,U
		SUBA -5,U	;DETERMINE EXPONENT DIFFERENCE.
		CMPA #32
		BHI FPADDEND	;DONE IF DIFFERENCE TOO BIG.
		LDB -9,U
		ANDB #$80
		STB ,-S		;STORE SIGN OF BIGGEST NUMBER.
		EORB -4,U
		STB ,-S		;STORE DIFFERENCE OF SIGNS.
		LDB -9,U
		ORB #$80
		STB -9,U
		LDB -4,U
		ORB #$80
		STB -4,U	;PUT THE HIDDEN MSBS BACK IN.
		CLR ,U		;MAKE EXTRA MANTISSA BYTE.
		TSTA
		BEQ FPADD2B	;SKIP THE ALIGNMENT PHASE.
FPALIGN		
    LSR -4,U
		ROR -3,U
		ROR -2,U
		ROR -1,U	;SHIFT THE SMALLER NUMBER RIGHT TO ALIGN
		ROR ,U
		DECA
		BNE FPALIGN
FPADD2B		
    TST ,S+
		BMI DOSUB	;DID SIGNS DIFFER? THEN SUBTRACT.
		LDD -7,U	;ADD THE MANTISSAS.
		ADDD -2,U
		STD -7,U
		LDD -9,U
		ADCB -3,U
		ADCA -4,U
		STD -9,U
		BCC FPADD2
FPADD2A		
    INC -10,U	;SUM OVERFLOWED, INC EXP, SHIFT MANT.
		LBEQ FPOVF	;IF EXPONENT OVERFLOWED, TOO BAD.
		ROR -9,U
		ROR -8,U
		ROR -7,U
		ROR -6,U
		ROR ,U
FPADD2		
    TST ,U
		BPL FPADD3	;TEST MSB OF EXTRA MANTISSA BYTE.		
		LDD -7,U	;ADD 1 TO MANTISSA IF THIS IS SET
		ADDD #1         
		STD -7,U	
		BCC FPADD3
		LDD -9,U
		CLR ,U
		ADDD #1
		STD -9,U
		BCS FPADD2A	
FPADD3		
    LDB -9,U
		ANDB #$7F
		EORB ,S+
		STB -9,U	;PUT ORIGINAL SIGN BACK IN.		
FPADDEND 	LEAU -5,U
		RTS		

DOSUB		
    LDB ,U
		NEGB
		STB ,U
		LDD -7,U	;SIGNS DIFFERED, SO SBUTRACT.
		SBCB -1,U
		SBCA -2,U
		STD -7,U
		LDD -9,U
		SBCB -3,U
		SBCA -4,U
		STD -9,U
		BMI FPADD2	;NUMBER STILL NORMALIZED, THEN DONE.
		LDD -9,U
		BNE FPNORM
		LDD -7,U
		BNE FPNORM
		TST ,U
		BEQ FPUNDF	;IF MANTISSA EXACTLY ZERO, UNDERFLOW.
FPNORM		
    TST -10,U	;DEC EXP, SHIFT MANT LEFT
		BEQ FPUNDF	;UNDERFLOW, PUT A ZERO IN. 
		DEC -10,U
		ASL ,U
		ROL -6,U
		ROL -7,U
		ROL -8,U
		ROL -9,U
		BPL FPNORM	;UNTIL NUMBER IS NORMALIZED.
		BRA FPADD2
		
FPUNDF		
    CLR -10,U	;UNDERFLOW, SUBSTITUTE ZERO.
		CLR -9,U
		CLR -8,U
		CLR -7,U
		CLR -6,U
		LEAS 1,S	;DISCARD THE SIGN ON STACK.
		BRA FPADDEND

; COMPARE FLOATING POINT NUMBERS, FLAGS AS WITH UNSIGNED COMPARISON.
FPCMP		LDA -9,U
		ANDA #$80
		STA ,-S
		LDA -4,U
		ANDA #$80
		SUBA ,S+	;SUBTRACT THE SIGNS, SUBTRACTION IS REVERSED.
		BNE FPCMPEND
		TST -9,U
		BMI FPCMPNEG	;ARE NUMBERS NEGATIVE?	
		JMP FPCMPMAG
FPCMPNEG	JSR FPCMPMAG
		BEQ FPCMPEND	
		TFR CC,A
		EORA #$1
		TFR A,CC	;REVERSE THE CARRY FLAG.
FPCMPEND	RTS

; MULTIPLY FLOATING POINT NUMBERS.
FPMUL		LDA -9,U
		EORA -4,U
		ANDA #$80
		STA ,-S		;SIGN DIFFERENCE TO STACK.
		JSR FPTEST0	;TEST ONE OPERAND FOR 0
		BEQ FPUNDF	
		LDD -7,U
		BNE FPMULA		
		LDD -9,U
		BNE FPMULA	;AND THE OTHER ONE.
		LDB -10,U
		BEQ FPUNDF
FPMULA		LDB -9,U
		ORB #$80
		STB -9,U
		LDB -4,U
		ORB #$80
		STB -4,U	;PUT HIDDEN MSB BACK IN.
		LDA -10,U
		SUBA #$80	;MAKE UNBIASED SIGNED NUM OF EXPONENTS.
		STA ,-S
		LDA -5,U
		SUBA #$80
		ADDA ,S+	;ADD EXPONENTS.
		BVC FPMUL1	;CHECK OVER/UNDERFLOW
		LBMI FPOVF
		BRA FPUNDF
FPMUL1		ADDA #$80	;MAKE EXPONENT BIASED AGAIN.
		STA -10,U	;STORE RESULT EXPONENT.
; NOW PERFORM MULTIPLICATION OF MANTISSAS TO 40-BIT PRODUCT.
; 0,U--4,U PRODUCT. 5,U--9,U ADDED TERM
; HAVING A MUL INSTRUCTION IS NICE, BUT USING IT FOR AN EFFICIENT 
; MULTIPRECISION MULTIPLICATON IS HARD. THIS ROUTINE HAS 13 MUL INSTRUCTIONS.
		LDA -1,U
		LDB -8,U
		MUL		;B4*A2
		STA 4,U
		LDA -1,U
		LDB -9,U
		MUL		;B4*A1
		ADDB 4,U
		ADCA #0
		STD 3,U
		LDA -2,U
		LDB -7,U
		MUL		;B3*A3
		STA 9,U
		LDA -2,U
		LDB -8,U
		MUL		;B3*A2
		ADDB 9,U
		ADCA #0
		STD 8,U
		LDA -2,U
		LDB -9,U
		MUL		;B3*A1
		ADDB 8,U
		ADCA #0
		STD 7,U
		LDD 8,U
		ADDD 3,U
		STD 3,U
		LDB 7,U
		ADCB #0
		STB 2,U		;ADD B4*A AND B3*A PARTIAL PRODUCTS.
		LDA -3,U
		LDB -6,U
		MUL		;B2*A4
		STA 9,U
		LDA -3,U
		LDB -7,U
		MUL		;B2*A3
		ADDB 9,U
		ADCA #0
		STD 8,U
		LDA -3,U
		LDB -8,U
		MUL		;B2*A2
		ADDB 8,U
		ADCA #0
		STD 7,U
		LDA -3,U
		LDB -9,U	;B2*A1
		MUL	
		ADDB 7,U
		ADCA #0
		STD 6,U
		LDD 8,U
		ADDD 3,U
		STD 3,U
		LDD 6,U
		ADCB 2,U
		ADCA #0
		STD 1,U		;ADD B2*A PARTIAL PRODUCT IN.
		LDA -4,U
		LDB -6,U
		MUL		;B1*A4
		STD 8,U
		LDA -4,U
		LDB -7,U
		MUL		;B1*A3
		ADDB 8,U
		ADCA #0
		STD 7,U
		LDA -4,U
		LDB -8,U
		MUL		;B1*A2
		ADDB 7,U
		ADCA #0
		STD 6,U
		LDA -4,U
		LDB -9,U
		MUL		;B1*A1
		ADDB 6,U
		ADCA #0
		STD 5,U
		LDD 8,U
		ADDD 3,U
		STD -6,U
		LDD 6,U
		ADCB 2,U
		ADCA 1,U
		STD -8,U	
		LDB 5,U
		ADCB #0
		STB -9,U	;ADD PRODUCT TERM B1*A IN, RESULT TO DEST.
		BMI FPMUL2	
		ASL -5,U
		ROL -6,U
		ROL -7,U
		ROL -8,U
		ROL -9,U	;NORMALIZE BY SHIFTING MANTISSA LEFT.
		BRA FPMUL3
FPMUL2		INC -10,U	;INCREMENT EXPONENT.
		LBEQ FPOVF	;TEST FOR OVERFLOW.
FPMUL3		TST -5,U	
		LBPL FPADD3
		LDD -7,U	;ADD 1 IF MSB OF 5TH NIBBLE IS SET.
		ADDD #1
		STD -7,U
		LBCC FPADD3
		LDD -9,U
		ADDD #1
		STD -9,U
		BCS FPMUL4	;IT COULD OVERFLOW.
		LBRA FPADD3
FPMUL4		CLR -5,U
		BRA FPMUL2

; DIVIDE FLOATING POINT NUMBERS.
FPDIV		LDA -9,U
		EORA -4,U
		ANDA #$80
		STA ,-S		;SIGN DIFFERENCE TO STACK.
		JSR FPTEST0	;TEST DIVISOR FOR 0
		LBEQ FPOVF	
		LDD -7,U
		BNE FPDIVA		
		LDD -9,U
		BNE FPDIVA	;AND THE OTHER ONE.
		LDB -10,U
		LBEQ FPUNDF
FPDIVA		LDB -9,U
		ORB #$80
		STB -9,U
		LDB -4,U
		ORB #$80
		STB -4,U	;PUT HIDDEN MSB BACK IN.
		LDA -5,U
		SUBA #$80	;MAKE UNBIASED SIGNED DIFFERENCE OF EXPONENTS.
		STA ,-S
		LDA -10,U
		SUBA #$80
		SUBA ,S+	;SUBTRACT EXPONENTS.
		BVC FPDIV1	;CHECK OVER/UNDERFLOW
		LBMI FPOVF
		LBRA FPUNDF
FPDIV1		ADDA #$80	;MAKE EXPONENT BIASED AGAIN.
		STA -10,U	;STORE RESULT EXPONENT.
; NOW START THE DIVISION OF MANTISSAS. TEMPRORARY 34-BIT QUOTIENT IN 0,U--4,U
; -5,U IS EXTRA BYTE OF DIVIDEND.
		LDA #34
		STA ,-S
		CLR ,U
		CLR 1,U
		CLR 2,U
		CLR 3,U
		CLR 4,U
		CLR -5,U
FPDIVLOOP	ASL 4,U		;SHIFT QUOTIENT LEFT.
		ROL 3,U
		ROL 2,U
		ROL 1,U
		ROL ,U		
		LDD -7,U	;PERFORM TRIAL SUBTRACTION.
		SUBD -2,U	
		STD -7,U
		LDD -9,U
		SBCB -3,U
		SBCA -4,U
		STD -9,U
		LDB -5,U
		SBCB #0
		BCC FPDIV2
		LDD -7,U	;UNDO THE TRIAL SUBTRACTION.		
		ADDD -2,U	
		STD -7,U
		LDD -9,U
		ADCB -3,U
		ADCA -4,U
		STD -9,U
		BRA FPDIV4
FPDIV2		STB -5,U	;STORE NEW MSB OF QUOTIENT.
		LDA 4,U		;ADD 1 TO QUOTIENT.
		ADDA #$40
		STA 4,U
FPDIV4		ASL -6,U	;SHIFT DIVIDEND LEFT.
		ROL -7,U
		ROL -8,U
		ROL -9,U
		ROL -5,U
		DEC ,S
		BNE FPDIVLOOP
		LEAS 1,S
		LDD 3,U
		STD -6,U
		LDD 1,U
		STD -8,U
		LDB ,U
		STB -9,U	;MOVE QUOTIENT TO FINAL LOCATION.
		BMI FPDIV3	
FPDIV5		ASL -5,U
		ROL -6,U
		ROL -7,U
		ROL -8,U
		ROL -9,U	;NORMALIZE BY SHIFTING MANTISSA LEFT.
		LDB -10,U	;DECREMENT EXPONENT.
		LBEQ FPUNDF	;TEST FOR UNDERFLOW.
		DECB
		STB -10,U
FPDIV3		TST -5,U	
		LBPL FPADD3
		LDD -7,U	;ADD 1 IF MSB OF 5TH NIBBLE IS SET.
		ADDD #1
		STD -7,U
		LBCC FPADD3
		LDD -9,U
		ADDD #1
		STD -9,U
		LBCS FPMUL4	;THIS ADDITION COULD OVERFLOW.
		LBRA FPADD3				

; FLOATING POINT NEGATION.
FPNEG		JSR FPTEST0
		BEQ FPNEGEND	;DO NOTHING IF NUMBER EQUALS ZERO.
		LDA -4,U
		EORA #$80
		STA -4,U	;INVERT THE SIGN BIT.	
FPNEGEND	RTS

; CONVERT UNSIGNED DOUBLE NUMBER AT X TO FLOAT.
UFLOAT		LEAU 5,U	;MAKE ROOM FOR EXTRA NUMBER ON STACK.
		LDD ,X
		STD -4,U
		LDD 2,X
		CLR -5,U
UF16		STD -2,U	;TRANSFER INTEGER TO FP NUMBER.	
		JSR FPTEST0
		BEQ UFZERO
		LDB #$9F	;NUMBER IS NOT ZERO.		
		STB -5,U
		TST -4,U
		BMI UFDONE
UFLOOP		DEC -5,U	;DECREMENT EXPONENT.
		ASL -1,U
		ROL -2,U
		ROL -3,U
		ROL -4,U	;SHIFT MANTISSA.
		BPL UFLOOP	;UNTIL NORMALIZED.
UFDONE		LDB -4,U
		ANDB #$7F
		STB -4,U	;REMOVE THE HIDDEN MSB.
UFEND		JMP FCKMEM 	;CHECK THAT FP STACK DOES NOT OVERFLOW
UFZERO		CLR -5,U	;MAKE EXPONENT ZERO AS WELL.
		BRA UFEND

; CONVERT UNSIGNED 16-BIT INTEGER IN D TO FLOATING POINT.
UNINT2FP	CLR ,-S
		BRA I2FP2
; CONVERT SIGNED 16-BIT INTEGER IN D TO FLOATING POINT.
INT2FP		STA ,-S		;STORE SIGN BYTE.
		BPL I2FP2
		COMB
		COMA
		ADDD #1		;NEGATE D IF NEGATIVE.
I2FP2		LEAU 5,U
		CLR -4,U
		CLR -5,U
		CLR -3,U	;CLEAR MSB	
		JSR UF16	
		TST ,S+
		BMI FPNEG
		RTS		;NEGATE NUMBER IF IT WAS NEGATIVE.

; CONVERT FLOAT TO UNSIGNED 32-BIT INTEGER AT X.
; A IS NONZERO IF NUMBER WAS NOT INTEGER OR ZERO.
UINT		
    LDD -4,U
		ORA #$80	;PUT THE HIDDEN MSB BACK IN.
		STD ,X
		LDD -2,U
		STD 2,X		;TRANSFER MANTISSA.
		CLRA
		LDB -5,U
		CMPB #$80	;IF LESS THAN 1, IT'S 0		
		BLO UIZERO
		CMPB #$9F
		LBHI INTRANGE	;2^32 OR HIGHER, THAT'S TOO BAD. 		
		BEQ UIDONE
UILOOP		
    LSR ,X
		ROR 1,X
		ROR 2,X
		ROR 3,X		;ADJUST INTEGER BY SHIFTING TO RIGHT
		ADCA #0		;ADD ANY SHIFTED OUT BIT INTO A.
		INCB				
		CMPB #$9F
		BLO UILOOP 
UIDONE		
    LEAU -5,U
		RTS
UIZERO		
    INCA		; INDICATE NON-INTEGER.
		CLR ,X		; NUMBER IS ZERO
		CLR 1,X
		CLR 2,X
		CLR 3,X
		LEAU -5,U
	        RTS   

; CONVERT FP NUMBER TO SIGNED OR UNSIGNED 16-BIT NUMBER IN D.
; ACCEPTABLE VALUES ARE -65535..65535.
FP2UINT		
    	LDB -4,U ; ***X***
		; ANDB #$80
		STB ,-S		;STORE SIGN.
		LDX #INTBUF	
		BSR UINT
		LDX ,X
		LBNE INTRANGE	;INTEGER MUST BE IN 16-BIT RANGE.
		LDD INTBUF+2
		TST ,S+
		BPL FP2IEND
		COMB
		COMA
		ADDD #1		;NEGATE NUMBER IF NEGATIVE.
FP2IEND		RTS
; CONVERT FP NUMBER TO SIGNED 16-BIT NUMBER IN D. 
FP2INT		LDB -4,U
		; ANDB #$80
		STB ,-S		;STORE SIGN OF FP NUMBER.
		BSR FP2UINT
		LDB ,S
		PSHS D
		EORA ,S+
		LBMI INTRANGE	;COMPARE SIGN TO WHAT IT SHOULD BE. 
		PULS D
		ANDB #$80
		CMPB #$80
		BEQ FP2INTNEG
		LDD INTBUF+2
		PULS PC
FP2INTNEG
		LDD INTBUF+2
		COMB
		COMA
		ADDD #1
		PULS PC

; SCAN A NUMBER AT ADDRESS Y AND CONVERT TO INTEGER OR FLOATING POINT
SCANNUM		JSR SKIPSPACE
		CLR ,-S		;STORE SIGN ON STACK.
		CMPB #'-'	;TEST FOR MINUS SIGN.
		BNE SN1
		INC ,S		;SET SIGN ON STACK
		LDB ,Y+
SN1		JSR SCANINT	;FIRST SCAN THE NUMBER AS AN INTEGER.
		LDX #INTBUF
		JSR UFLOAT	;CONVERT TO FLOAT.
		LDB -1,Y
SN1LOOP		CMPB #'.'
		BNE SN1C
		TST DPL		;IF DPL ALREADY SET, ACCEPT NO OTHER POINT.
		BNE SN1D
		INC DPL
		LDB ,Y+
		BRA SN1LOOP
SN1C		SUBB #'0'
		BLO SN1D
		CMPB #9
		BHI SN1D
		CLRA
		JSR INT2FP	;CONVERT DIGIT TO FP
		JSR FPEXG
		LDX #FPTEN
		JSR FPLOD
		JSR FPMUL	;MULTIPLY ORIGINAL NUMBER BY 10.
		JSR FPADD	;ADD DIGIT TO IT.
		TST DPL
		BEQ SN1K
		INC DPL		;ADJUST DPL (ONE MORE DIGIT AFTER .)
SN1K		LDB ,Y+
		BRA SN1LOOP		
SN1D		TST ,S+
		BEQ SN1A
		JSR FPNEG	;NEGATE THE NUMBER IF NEGATIVE.
SN1A		CLR ,-S
		CLR ,-S		;PREPARE EXPONENT PART ON STACK.
		LDB -1,Y
		CMPB #'e'
		BEQ SN1E
		CMPB #'E'
		BNE SN1F	;TEST FOR EXPONENT PART.
SN1E		LDB ,Y+
		CLR ,-S		;PREPARE EXPONENT SIGN ON STACK.
		CMPB #'+'
		BEQ SN1G
		CMPB #'-'
		BNE SN1H
		INC ,S		;SET SIGN TO NEGATIVE.
SN1G		LDB ,Y+
SN1H		LDA DPL
		PSHS A
		CLR DPL
		INC DPL
		JSR SCANINT	;SCAN THE EXPONENT PART.
		PULS A
		STA DPL		;RESTORE DPL.
		LDA INTBUF
		ORA INTBUF+1
		ORA INTBUF+2
		LBNE FPOVF	;EXPONENT MAY NOT BE GREATER THAN 255.
		LDB INTBUF+3
		LBMI FPOVF	;NOT EVEN GREATER THAN 127.
		TST ,S+
		BEQ SN1I
		NEGB
SN1I		SEX
		STD ,S
SN1F		LDB DPL
		BEQ SN1J
		DECB
SN1J		NEGB
		SEX
		ADDD ,S++	;ADD EXPONENT PART AS WELL
		PSHS D
		LDX #FPTEN
		JSR FPLOD
		PULS D
		JSR FPIPOWER
		JSR FPMUL
SN1B		RTS		

; SCAN INTEGER NUMBER BELOW 1E9 AT ADDRESS Y, FIRST DIGIT IN B.
SCANINT		CLR DPL
SCANINT1	CLR INTBUF
		CLR INTBUF+1
		CLR INTBUF+2
		CLR INTBUF+3	;INITIALIZE NUMBER
SNLOOP		CMPB #'.'	
		LBNE SN2A	;TEST FOR DECIMAL POINT.
		TST DPL
		LBNE SNDONE	;DONE IF SECOND POINT FOUND.
		INC DPL		;SET DPL TO INDICATE DECIMAL POINT.
		LBRA SN3
SN2A		SUBB #'0'
		LBLO SNDONE
		CMPB #9
		LBHI SNDONE	;CHECK THAT CHARACTER IS A DIGIT.
		TST DPL
		BEQ SN2B
		INC DPL		;INCREMEND DEECIMAL POINT LOC IF SET.
SN2B		PSHS B
		LDD INTBUF+2
		ASLB
		ROLA
		STD INTBUF+2
		STD INTBUF2+2
		LDD INTBUF
		ROLB
		ROLA
		STD INTBUF
		STD INTBUF2
		ASL INTBUF+3
		ROL INTBUF+2
		ROL INTBUF+1
		ROL INTBUF
		ASL INTBUF+3
		ROL INTBUF+2
		ROL INTBUF+1
		ROL INTBUF
		LDD INTBUF+2
		ADDD INTBUF2+2
		STD INTBUF+2
		LDD INTBUF
		ADCB INTBUF2+1
		ADCA INTBUF2
		STD INTBUF	;MULTIPLY THE INTEGER BY 10
		LDD INTBUF+2
		ADDB ,S+	;ADD THE DIGIT IN.
		ADCA #0
		STD INTBUF+2
		BCC SN2
		LDD INTBUF
		ADDD #1
		STD INTBUF
SN2		LDD INTBUF
		CMPD #$5F5      
		BLO SN3
		BHI SNOVF
		LDD INTBUF+2	;NOTE $5F5E100 IS 100 MILLION
		CMPD #$E100	;COMPARE RESULT TO 100 MILLION 
		BHS SNOVF
SN3		LDB ,Y+		;GET NEXT DIGIT.
		LBRA SNLOOP		
SNOVF		LDB ,Y+		;GET NEXT DIGIT.
SNDONE		LDB -1,Y
		RTS

*CONVERT INTEGER AT X TO BCD.
INT2BCD		CLR BCDBUF
		CLR BCDBUF+1
		CLR BCDBUF+2
		CLR BCDBUF+3
		CLR BCDBUF+4
		LDB #4
TSTZERO		TST ,X+
		BNE BCD1
		DECB
		BNE TSTZERO	;SKIP BYTES THAT ARE ZERO.
		BRA SNDONE	;DONE IF NUMBER ALREADY ZERO.	
BCD1		STB ,-S		;STORE NUMBER OF BYTES.
		LEAX -1,X
BCDLOOP		LDB #8
BCDLOOP1	ROL ,X		;GET NEXT BIT OF BINARY NUNBER
		LDA BCDBUF+4
		ADCA BCDBUF+4
		DAA
		STA BCDBUF+4
		LDA BCDBUF+3
		ADCA BCDBUF+3
		DAA
		STA BCDBUF+3
		LDA BCDBUF+2
		ADCA BCDBUF+2
		DAA
		STA BCDBUF+2
		LDA BCDBUF+1
		ADCA BCDBUF+1
		DAA
		STA BCDBUF+1
		LDA BCDBUF
		ADCA BCDBUF
		DAA
		STA BCDBUF	;ADD BCD NUMBER TO ITSELF PLUS THE EXTRA BIT.
		DECB
		BNE BCDLOOP1		
		LEAX 1,X
		DEC ,S
		BNE BCDLOOP
		LEAS 1,S	;REMOVE COUNTER FROM STACK.
		RTS

; RAISE FP NUMBER TO AN INTEGER POWER CONTAINED IN D. 
FPIPOWER	STA ,-S		;STORE SIGN OF EXPONENT.
		BPL FPPOW1	;IS EXPONENT NEGATIVE.
		COMA
		COMB
		ADDD #1		;TAKE ABSOLUTE VALUE OF EXPONENT.
FPPOW1		STD ,--S	;STORE THE EXPONENT.
		LDX #FPONE
		JSR FPLOD	;START WITH NUMBER ONE.
FPPOWLOOP	LSR ,S
		ROR 1,S		;DIVIDE EXPONENT BY 2.
		BCC FPPOW2	;TEST IF IT WAS ODD.
		LEAX -10,U
		JSR FPLOD
		JSR FPMUL	;MULTIPLY RESULT BY FACTOR.
FPPOW2		LDD ,S
		BEQ FPPOWDONE	;IS EXPONENT ZERO?
		LEAX -10,U
		JSR FPLOD
		JSR FPDUP
		JSR FPMUL	;SQAURE THE FACTOR.
		LEAX -15,U
		JSR FPSTO	;STORE IT IN ITS PLACE ON STACK.
		BRA FPPOWLOOP				
FPPOWDONE	LEAS 2,S	;REMOVE EXPONENT.
		TST ,S+
		BPL FPPOW3	;WAS EXPONENT NEGATIVE?
		LDX #FPONE
		JSR FPLOD
		JSR FPEXG
		JSR FPDIV	:COMPUTE 1/RESULT.
FPPOW3		JSR FPEXG
		LEAU -5,U	;REMOVE FACTOR FROM STACK.
		RTS								


; CONVERT FP NUMBER TO STRING AT ADDRESS Y IN SCIENTIFIC NOTATION.
FPSCIENT	
    ; LDB #15
		; STB ,Y+		;STORE THE STRING LENGTH.
		LDA #' '
		LDB -4,U
		BPL FPSC1
		LDA #'-'
FPSC1		
    STA ,Y+		;STORE - OR SPACE DEPENDING ON SIGN.
		ANDB #$7F
		STB -4,U	;MAKE NUMBER POSITIVE.
		CLR ,-S		;STORE DECIMAL EXPONENT (DEFAULT 0)
		JSR FPTEST0		
		BEQ FPSC2	;TEST FOR ZERO
		LDA -5,U
		SUBA #$80
		; SUBA #$1D	;ADJUST EXPONENT.
		BVC FPSC11A
		LDA #-128
FPSC11A		
  STA ,-S		;STORE IT TO RECOVER SIGN LATER.
		BPL POSEXP
		NEGA		;TAKE ABSOLUTE VALUE.
POSEXP		LDB #5
		MUL
		LSRA
		RORB
		LSRA
		RORB
		LSRA
		RORB
		LSRA
		RORB		;MULTIPLY BY 5/16 APPROX 10LOG 2
		CMPB #37
		BLS EXPMAX
		LDB #37	;MAXIMUM DECIMAL EXPONENT=37
EXPMAX		
    TST ,S+
		BPL POSEXP1
		NEGB
POSEXP1		
    STB ,S		;STORE APPROXIMATE DECIMAL EXPONENT.
		NEGB
		SEX		;APPROXIMATE (NEGATED) DECIMAL EXPONENT IN D.
		PSHS D
		LDX #FPTEN
		JSR FPLOD
		PULS D
		JSR FPIPOWER	;TAKE 10^-EXP
		JSR FPMUL
FPSC1A		
    LDX #FPLOLIM
		JSR FPLOD
		JSR FPCMPMAG	;COMPARE NUMBER TO 100 MILLION
		LEAU -5,U
		BHS FPSC1C
		DEC ,S		;DECREMENT APPROXIMATE EXPONENT.
		LDX #FPTEN
		JSR FPLOD
		JSR FPMUL	;MULTIPLY BY TEN.
		BRA FPSC1A
FPSC1C		
    LDX #FPHILIM
		JSR FPLOD
		JSR FPCMPMAG	;COMPARE NUMBER TO 1 BILLION
		LEAU -5,U
		BLO FPSC1D
		INC ,S		;INCREMENT APPROXIMATE EXPONENT.
		LDX #FPTEN
		JSR FPLOD
		JSR FPDIV	;DIVIDE BY TEN.
		BRA FPSC1C
FPSC1D		
    LDB ,S
		ADDB #8
		STB ,S		;ADJUST DECIMAL EXPONENT (8 DECIMALS)
		LDX #FPHALF
		JSR FPLOD
		JSR FPADD	;ADD 0.5 FOR THE FINAL ROUND TO INTEGER.		
; NUMBER IS EITHER ZERO OR BETWEEN 100 MILLION AND 1 BILLION.
FPSC2		
    LDX #INTBUF
		JSR UINT	;CONVERT DECIMAL MANTISSA TO INTEGER.
		JSR INT2BCD	;CONVERT TO BCD.
		LDB BCDBUF
		ADDB #'0'
		STB ,Y+		;STORE DIGIT BEFORE DECIMAL POINT
		LDB #'.'
		STB ,Y+		;STORE DECIMAL POINT.
		LDA #4
		STA ,-S
		LDX #BCDBUF+1
FPSCLOOP	
    LDA ,X+
		TFR A,B
		LSRB
		LSRB
		LSRB
		LSRB
		ADDB #'0'	
		STB ,Y+
		ANDA #$0F
		ADDA #'0'	
		STA ,Y+
		DEC ,S		;CONVERT THE OTHER 8 DIGITS TO ASCII
		BNE FPSCLOOP
		LEAS 1,S	;REMOVE LOOP COUNTER.
		LDB #'E'
		STB ,Y+		;STORE THE E CHARACTER.
		LDA #'+'
		LDB ,S+		;GET DECIMAL EXPONENT.
		BPL FPSC3	;TEST SIGN OF EXPONENT.
		LDA #'-'
		NEGB		;TAKE ABSOLUTE VALUE OF EXPONENT.
FPSC3		
    STA ,Y+		;STORE SIGN OF EXPONENT.
		STB INTBUF+3
		CLR INTBUF+2
		CLR INTBUF+1
		CLR INTBUF
		LDX #INTBUF
		JSR INT2BCD	;CONVERT DECIMAL EXPONENT TO BCD.
		LDA BCDBUF+4
		TFR A,B
		LSRB
		LSRB
		LSRB
		LSRB
		ADDB #'0'	
		STB ,Y+		;CONVERT FIRST EXP DIGIT TO ASCII
		ANDA #$0F
		ADDA #'0'
		STA ,Y+		;AND THE SECOND ONE.
		RTS


* THESE ARE THE FLOATING POINT CONSTANTS.
* THEY ARE GENERATED BY THE PROGRAM MAKEFLOT.C
* SIMPLE CONSTANTS.
FPZERO           FCB $00,$00,$00,$00,$00 ;0
FPONE            FCB $80,$00,$00,$00,$00 ;1
FPTWO            FCB $81,$00,$00,$00,$00 ;2
FPTEN            FCB $83,$20,$00,$00,$00 ;10
FPHALF           FCB $7F,$00,$00,$00,$00 ;0.5
* NUMBERS USED IN CONVERSION.
FPLOLIM          FCB $9A,$3E,$BC,$1F,$FE ;99999999.95
FPHILIM          FCB $9D,$6E,$6B,$27,$FE ;999999999.5
* MATHEMATICAL CONSTANTS.
PI
FPI              FCB $81,$49,$0F,$DA,$A2 ;3.1415926535898
FLN2             FCB $7F,$31,$72,$17,$F8 ;0.6931471805599
* EVEN COEFFICIENTS FOR THE SIN(X)/X POLYNUMIAL.
SINCOEFF         FCB $66,$CD,$4C,$A7,$E3 ;-0.0000000239
                 FCB $6D,$38,$B9,$4E,$D4 ; 0.0000027526
                 FCB $73,$D0,$0C,$02,$A9 ;-0.0001984090
                 FCB $79,$08,$88,$86,$91 ; 0.0083333315
                 FCB $7D,$AA,$AA,$AA,$A6 ;-0.1666666664
* EVEN COEFFICIENTS FOR THE ARCTAN(X)/X POLYNOMIAL.
ATANCOEFF        FCB $77,$3B,$D7,$49,$A5 ; 0.0028662257
                 FCB $7A,$84,$6E,$01,$CE ;-0.0161657367
                 FCB $7B,$2F,$C1,$FD,$BF ; 0.0429096138
                 FCB $7C,$9A,$31,$74,$6C ;-0.0752896400
                 FCB $7C,$5A,$3D,$83,$56 ; 0.1065626393
                 FCB $7D,$91,$7F,$C7,$00 ;-0.1420889944
                 FCB $7D,$4C,$BB,$E4,$D9 ; 0.1999355085
                 FCB $7E,$AA,$AA,$6B,$91 ;-0.3333314528
* COEFFICIENTS FOR THE EXP(-X) POLYNOMIAL.
EXPCOEFF         FCB $73,$94,$2E,$40,$72 ;-0.0001413161
                 FCB $76,$2E,$4F,$6F,$65 ; 0.0013298820
                 FCB $79,$88,$02,$6D,$37 ;-0.0083013598
                 FCB $7B,$2A,$A0,$E5,$12 ; 0.0416573475
                 FCB $7D,$AA,$AA,$4F,$14 ;-0.1666653019
                 FCB $7E,$7F,$FF,$FD,$56 ; 0.4999999206
                 FCB $7F,$FF,$FF,$FF,$FE ;-0.9999999995
* COEFFICIENTS FOR THE LN(1+X) POLYNOMIAL.
LNCOEFF          FCB $78,$D3,$78,$40,$A4 ;-0.0064535442
                 FCB $7B,$13,$D1,$87,$43 ; 0.0360884937
                 FCB $7C,$C3,$3C,$0E,$19 ;-0.0953293897
                 FCB $7D,$2B,$AD,$82,$42 ; 0.1676540711
                 FCB $7D,$F6,$82,$EC,$68 ;-0.2407338084
                 FCB $7E,$29,$E1,$8F,$D9 ; 0.3317990258
                 FCB $7E,$FF,$EF,$80,$4C ;-0.4998741238
                 FCB $7F,$7F,$FF,$C4,$01 ; 0.9999964239
* END OF FLOATING POINT CONSTANTS.

FPOVF		SWI
INTRANGE	SWI
INVAL		SWI

; THIS ROUTINE TAKES THE SQUARE ROOT OF AN FP NUMBER.
; USES NEWTON'S ALGORITHM.
FPSQRT		TST -4,U
		LBMI INVAL	;NEGATIVE ARGUMENTS ARE INVALID.
		JSR FPTEST0
		BEQ SQDONE	;SQAURE ROOT OF 0 IS 0.
		JSR FPDUP
		LDB -5,U
		SUBB #$80	;UNBIAS THE EXPONENT.
		BPL SQ1
		ADDB #1
SQ1		ASRB		;DIVIDE EXPONENT BY 2.
		ADDB #$80	;MAKE IT BIASED AGAIN.
		STB -5,U	;THIS IS THE INITIAL GUESS FOR THE ROOT.
		LDB #4		;DO THE LOOP 4 TIMES.
		STB ,-S
SQLOOP		LEAX -10,U
		JSR FPLOD
		LEAX -10,U
		JSR FPLOD
		JSR FPDIV	;DIVIDE ARGUMENT BY GUESS.
		JSR FPADD	;ADD TO GUESS.
		DEC -5,U	;DIVIDE THIS BY TWO, GIVING NEW GUESS.
		DEC ,S
		BNE SQLOOP
		LEAS 1,S
		JSR FPEXG	
		LEAU -5,U	;REMOVE ARGUMENT, LEAVE FINAL GUESS.
SQDONE		RTS	
			
; COMPUTE THE FLOOR OF AN FP NUMBER (RESULT IS STILL FP.
FPFLOOR		LDB -5,U
		CMPB #$9F
		BHS SQDONE	;IF ABS VALUE >=2^31, THEN ALREADY INTEGER.
		LDB -4,U
		STB ,-S		;STROE SIGN OF NUMBER
		ANDB #$7F
		STB -4,U	;TAKE ABSOLUTE VALUE OF NUMBER.
		LDX #INTBUF
		JSR UINT	;CONVERT TO INT (TRUNCATION)
		STA ,-S		;STORE NUMBER OF FRACTION BITS.
		LDX #INTBUF
		JSR UFLOAT	;CONVERT BACK TO FLOAT
		LDD ,S++
		TSTB
		BPL SQDONE
		STA ,-S
		JSR FPNEG	;NEGATE NUMBER IF IT WAS NEGATIVE
		LDA ,S+
		BEQ SQDONE
		LDX #FPONE
		JSR FPLOD
		JMP FPSUB	;SUBTRACT 1 IF NEGATIVE & NOT INTEGER.
		
; FLOATING POINT MODULO OPERATION (FLOORED MODULO).
; INTEGER PART OF QUOTIENT IS STILL LEFT IN INTBUF
FPMOD		LEAX -10,U
		JSR FPLOD
		LEAX -10,U
		JSR FPLOD
		JSR FPDIV	;PERFORM DIVISION.
		JSR FPFLOOR
		JSR FPMUL	;MULTIPLY QUOTIENT AND DIVISOR
		LEAX -10,U
		JMP FPSUB	;DIVIDEND - QUOTIENT*DIVISOR = MODULUS.		
		

; NOW THE TRANSCENDENTAL FUNCTIONS FOLLOW.
; THEY USE APPROXIMATION POLYNOMIALS AS DEFINED IN THE
; HANDBOOK OF MATHEMATICAL FUNCTIONS BY ABRAMOWITZ & STEGUN.

; COMPUTE POLYNOMIAL, NUMBER OF TERMS IN B, COEFFICIENTS START AT Y
FPPOLY		STB ,-S
		LDX #FPZERO
		JSR FPLOD	;START WITH ZERO.
POLYLOOP	LEAX ,Y
		JSR FPLOD
		JSR FPADD	;ADD NEXT COEFFICIENT.
		LEAY 5,Y	
		LEAX -10,U		
		JSR FPLOD
		JSR FPMUL	;MULTIPLY BY X.
		DEC ,S
		BNE POLYLOOP
		LEAS 1,S
		JSR FPEXG
		LEAU -5,U	;REMOVE X FROM STACK.
		RTS

ADD1		LDX #FPONE
		JSR FPLOD
		JSR FPADD
		RTS

HALFPI		LDX #FPI
		JSR FPLOD
		DEC -5,U
		RTS

; SIN(X)
FPSIN		LDX #FPI
		JSR FPLOD
		INC -5,U	;LOAD 2*PI
		JSR FPMOD	;MODULO 2PI
		BSR HALFPI
		JSR FPCMP	;COMPARE X TO PI/2
		BLS SIN2
		INC -5,U	;CHANGE PI/2 TO PI
		JSR FPSUB
		JSR FPNEG	;X := PI-X IF X>PI/2
		BSR HALFPI
		JSR FPNEG
		JSR FPCMP	;COMPARE X TO -PI/2
		BHS SIN2
		INC -5,U	;CHANGE -PI/2 TO -PI
		JSR FPSUB
		JSR FPNEG
		BRA SIN3
SIN2		LEAU -5,U	;DROP THE COMPARE LIMIT PI/2 OR -PI/2
SIN3		JSR FPDUP
		JSR FPDUP
		JSR FPMUL	;ON STACK: X, X*X
		LDY #SINCOEFF
		LDB #5
		JSR FPPOLY	;DO THE SINE POLYNOMIAL WITH X*X AS ARGUMENT
		JSR ADD1	;ADD 1 TO THE RESULT.
		JMP FPMUL	;MULTIPLY THE POLYNOMIAL RESULT WITH X.				
; COS(X)
FPCOS		JSR HALFPI 	;COMPUTE SIN(X+PI/2)	-> PI/2
		JSR FPADD		;COMPUTE SIN(X+PI/2) 	-> PI/2+X
		; JSR FPNEG
		BRA FPSIN		;COMPUTE SIN(PI/2-X)

; TAN(X)	
FPTAN		JSR FPDUP
		JSR FPSIN
		JSR FPEXG
		JSR FPCOS
		JMP FPDIV	;COMPUTE SIN(X)/COS(X)

; ATAN(X)
FPATAN		CLR ,-S		;MAKE FLAG ON STACK
		LDB -5,U
		CMPB #$80	;COMPARE MAGNITUDE TO 1.
		BLO ATN1
		INC ,S		;SET FLAG ON STACK.
		LDX #FPONE	;IF X>1 THEN COMPUTE 1/X
		JSR FPLOD
		JSR FPEXG
		JSR FPDIV
ATN1		JSR FPDUP
		JSR FPDUP
		JSR FPMUL	;ON STACK: X, X*X
		LDB #8
		LDY #ATANCOEFF
		JSR FPPOLY	;DOE THE ARCTAN POLYNOMYAL, X*X AS ARGUMENT.
		JSR ADD1	;ADD 1 TO RESULT
		JSR FPMUL	;MULTIPLY RESULT BY X.
		TST ,S+
		BEQ ATNDONE		
		JSR HALFPI
		JSR FPSUB
		JSR FPNEG	;COMPUTE PI/2 - RESULT WHEN X WAS >1
ATNDONE		RTS

; EXP(X)
FPEXP		LDB -4,U
		STB ,-S		;STORE SIGN OF X.
		ANDB #$7F
		STB -4,U	;TAKE ABSOLUTE VALUE.
		LDX #FLN2
		JSR FPLOD
		JSR FPMOD	;MODULO LN2.
		LDB #7
		LDY #EXPCOEFF
		JSR FPPOLY	;DO THE EXP(-X) POLYNOMIAL.
		JSR ADD1
		TST ,S+
		BPL EXPPOS
		LDB -5,U	;NUMBER WAS NEGATIVE.
		SUBB INTBUF+3	;SUBTRACT THE INTEGER QUOTIENT OF THE MODLN2	
		BCS EXPUND	
		LDA INTBUF
		ORA INTBUF+1
		ORA INTBUF+2
		BNE EXPUND	;UNDERFLOW ALSO IF QUOTIENT >255
		STB -5,U	;STORE EXPONENT.
		RTS
EXPPOS		LDX #FPONE
		JSR FPLOD
		JSR FPEXG
		JSR FPDIV	;X WAS POSTITIVE, COMPUTE 1/EXP(-X)
		LDB INTBUF
		ORB INTBUF+1
		ORB INTBUF+2	;CHECK INT PART IS LESS THAN 255
		LBNE FPOVF
		LDB -5,U
		ADDB INTBUF+3	;ADD INTEGER PART TO EXPONENT.
		LBCS FPOVF	;CHECK FOR OVERFLOW.	
		STB -5,U
		RTS
EXPUND		LEAU -5,U
		LDX #FPZERO
		JMP FPLOD	;UNDERFLOW, RESULT IS ZERO.

; LN(X) NATURAL LOGARITHM
FPLN	JSR FPTEST0
		LBEQ INVAL	;DON'T ACCEPT ZERO AS ARGUMENT.
		TST -4,U
		LBMI INVAL	;NO NEGATIVE NUMBERS EITHER.
		LDB -5,U
		STB ,-S		;SAVE THE BINARY EXPONENT.
		LDB #$80
		STB -5,U	;REPLACE EXPONENT WITH 1.
		LDX #FPONE	;ARGUMENT IS NOW IN RANGE 1..2
		JSR FPLOD
		JSR FPSUB	;SUBTRACT 1.
		LDY #LNCOEFF
		LDB #8
		JSR FPPOLY	;DO THE LN(1+X) POLYNOMIAL.
		LDB ,S+		;GET ORIGINAL EXPONENT.
		SUBB #$80	;UNBIAS IT.
		SEX
		JSR INT2FP	;CONVERT TO FP.
		LDX #FLN2
		JSR FPLOD
		JSR FPMUL	;MULTIPLY IT BY LN2.
		JMP FPADD	;ADD THAT TO RESULT.

SKIPSPACE	LDB ,Y+
		CMPB #' ' 
		BEQ SKIPSPACE
		RTS
