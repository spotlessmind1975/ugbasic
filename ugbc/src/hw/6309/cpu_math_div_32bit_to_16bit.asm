; /*****************************************************************************
;  * ugBASIC - an isomorphic BASIC language compiler for retrocomputers        *
;  *****************************************************************************
;  * Copyright 2021-2025 Marco Spedaletti (asimov@mclink.it)
;  *
;  * Licensed under the Apache License, Version 2.0 (the "License");
;  * you may not use this file except in compliance with the License.
;  * You may obtain a copy of the License at
;  *
;  * http://www.apache.org/licenses/LICENSE-2.0
;  *
;  * Unless required by applicable law or agreed to in writing, software
;  * distributed under the License is distributed on an "AS IS" BASIS,
;  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;  * See the License for the specific language governing permissions and
;  * limitations under the License.
;  *----------------------------------------------------------------------------
;  * Concesso in licenza secondo i termini della Licenza Apache, versione 2.0
;  * (la "Licenza"); è proibito usare questo file se non in conformità alla
;  * Licenza. Una copia della Licenza è disponibile all'indirizzo:
;  *
;  * http://www.apache.org/licenses/LICENSE-2.0
;  *
;  * Se non richiesto dalla legislazione vigente o concordato per iscritto,
;  * il software distribuito nei termini della Licenza è distribuito
;  * "COSì COM'è", SENZA GARANZIE O CONDIZIONI DI ALCUN TIPO, esplicite o
;  * implicite. Consultare la Licenza per il testo specifico che regola le
;  * autorizzazioni e le limitazioni previste dalla medesima.
;  ****************************************************************************/

CPUMATHDIV32BITTO16BIT
CPUMATHDIV32BITTO16BIT_SIGNED
                    ; * EXIT INDICATING NO ERROR IF LENGTH OF OPERANDS IS ZERO 
    LDB 2, S        ; TEST LENGTH OF OPERANDS
                    ; BRANCH (GOOD EXIT) IF LENGTH IS ZERO
    BEQ CPUMATHDIV32BITTO16BITGOODRT
; SET UP HIGH DIVIDEND AND DIFFERENCE POINTERS
; CLEAR HIGH DIVIDEND AND DIFFERENCE ARRAYS
; ARRAYS 1 AND 2 ARE USED INTERCHANGEABLY FOR THESE TWO
; PURPOSES. THE POINTERS ARE SWITCHED WHENEVER A
; TRIAL SUBTRACTION SUCCEEDS

    ; GET BASE ADDRESS OF ARRAY 1
    LDX #CPUMATHDIV32BITTO16BITHIDE1
    ; DIVIDEND POINTER = ARRAY 1
    STX CPUMATHDIV32BITTO16BITHDEPTR
    ; GET BASE ADDRESS OF ARRAY 2
    LDU #CPUMATHDIV32BITTO16BITHIDE2
    ; DIFFERENCE POINTER = ARRAY 2
    STU CPUMATHDIV32BITTO16BITDIFPTR

    CLRA            ; GET ZERO FOR CLEARING ARRAYS

CPUMATHDIV32BITTO16BITCLRHI 
    STA ,X+         ; CLEAR BYTE OF ARRAY 1
    STA ,U+         ; CLEAR BYTE OF ARRAY 2
    DECB
    ; CONTINUE THROUGH ALL BYTES
    BNE CPUMATHDIV32BITTO16BITCLRHI       

; CHECK WHETHER DIVISOR IS ZERO
; IF IT IS, EXIT INDICATING DIVIDE-BY-ZERO ERROR

    LDB 2,S         ; GET LENGTH OF OPERANDS
    LDX 3,S         ; GET BASE ADDRESS OF DIVISOR
CPUMATHDIV32BITTO16BITCHKZRO
    LDA ,X+         ; EXAMINE BYTE OF DIVISOR
    ; BRANCH IF BYTE IS NOT ZERO
    BNE CPUMATHDIV32BITTO16BITINITDV      
    DECB            ; CONTINUE THROUGH ALL BYTES
    BNE CPUMATHDIV32BITTO16BITCHKZRO
    ORCC #$01             ; ALL BYTES ARE ZERO - INDICATE DIVIDE-BY-ZERO ERROR
    BRA CPUMATHDIV32BITTO16BITDVEXIT      ; EXIT

; SET COUNT TO NUMBER OF BITS IN THE OPERANDS
; COUNT (LENGTH * 8)
CPUMATHDIV32BITTO16BITINITDV
    LDB 2,S         ; GET LENGTH OF OPERANDS IN BYTES
    LDA #8          ; MULTIPLY LENGTH TIMES 8
    MUL
    PSHS D          ; SAVE BIT COUNT AT TOP OF STACK

; DIVIDE USING TRIAL SUBTRACTIONS

    ANDCC #$FE             ; START QUOTIENT WITH O BIT
CPUMATHDIV32BITTO16BITSHFTST
    LDX 7,S         ; POINT TO BASE ADDRESS OF DIVIDEND
    LDB 4,S         ; GET LENGTH OF OPERANDS IN BYTES

; SHIFT QUOTIENT AND LOWER DIVIDEND LEFT ONE BIT
CPUMATHDIV32BITTO16BITSHFTQU
    ROL ,X+         ; SHIFT BYTE OF QUOTIENT/DIVIDEND LEFT
    DECB            ; CONTINUE THROUGH ALL BYTES 
    BNE CPUMATHDIV32BITTO16BITSHFTQU

; SHIFT UPPER DIVIDEND LEFT WITH CARRY FROM LOWER DIVIDEND
    LDX CPUMATHDIV32BITTO16BITHDEPTR      ; POINT TO BASE ADDRESS OF UPPER DIVIDEND
    LDB 4,S         ; GET LENGTH OF OPERANDS IN BYTES
CPUMATHDIV32BITTO16BITSHFTRM
    ROL ,X+         ; SHIFT BYTE OF UPPER DIVIDEND LEFT
    DECB            ; CONTINUE THROUGH ALL BYTES
    BNE CPUMATHDIV32BITTO16BITSHFTRM

; TRIAL SUBTRACTION OF DIVISOR FROM DIVIDEND
; SAVE DIFFERENCE IN CASE IT IS NEEDED LATER

    LDU CPUMATHDIV32BITTO16BITDIFPTR      ; POINT TO DIFFERENCE
    LDX CPUMATHDIV32BITTO16BITHDEPTR      ; POINT TO UPPER DIVIDEND
    LDY 5,S         ; POINT TO DIVISOR
    LDB 4,S         ; GET LENGTH OF OPERANDS IN BYTES
    ANDCC #$FE             ; CLEAR BORROW INITIALLY
CPUMATHDIV32BITTO16BITSUBDVS
    LDA ,X+         ; GET BYTE OF UPPER DIVIDEND
    SBCA ,Y+        ; SUBTRACT BYTE OF DIVISOR WITH BORROW
    STA ,U+         ; SAVE DIFFERENCE
    DECB            ; CONTINUE THROUGH ALL BYTES
    BNE CPUMATHDIV32BITTO16BITSUBDVS

; NEXT BIT OF QUOTIENT IS 1 IF SUBTRACTION WAS SUCCESSFUL,
; O IF IT WAS NOT
; THIS IS COMPLEMENT OF FINAL BORROW FROM SUBTRACTION

    ; BRANCH IF SUBTRACTION WAS SUCCESSFUL,
    BCC CPUMATHDIV32BITTO16BITRPLCDV      
                    ; * I.E., IT PRODUCED NO BORROW
    ANDCC #$FE             ; OTHERWISE, TRIAL SUBTRACTION FAILED SO
                    ; * MAKE NEXT BIT OF QUOTIENT ZERO
    BRA CPUMATHDIV32BITTO16BITSETUP       
    
; TRIAL SUBTRACTION SUCCEEDED, SO REPLACE UPPER DIVIDEND
; WITH DIFFERENCE BY SWITCHING POINTERS
; SET NEXT BIT OF QUOTIENT TO 1
CPUMATHDIV32BITTO16BITRPLCDV
    ; GET HIGH DIVIDEND POINTER
    LDX CPUMATHDIV32BITTO16BITHDEPTR      
    ; GET DIFFERENCE POINTER
    LDU CPUMATHDIV32BITTO16BITDIFPTR      
    ; NEW HIGH DIVIDEND = DIFFERENCE
    STU CPUMATHDIV32BITTO16BITHDEPTR      
    ; USE OLD HIGH DIVIDEND FOR NEXT DIFFERENCE
    STX CPUMATHDIV32BITTO16BITDIFPTR      
    ORCC #$01             ; SET NEXT BIT OF QUOTIENT TO 1

; DECREMENT 16-BIT BIT COUNT BY 1
CPUMATHDIV32BITTO16BITSETUP
    LDX ,S          ; GET SHIFT COUNT
    LEAX -1,S       ; DECREMENT SHIFT COUNT BY 1
    STX ,S          
    ; CONTINUE UNLESS SHIFT COUNT EXHAUSTED
    BNE CPUMATHDIV32BITTO16BITSHFTST      

; SHIFT LAST CARRY INTO QUOTIENT IF NECESSARY 

    LEAS 2,S        ; REMOVE SHIFT COUNTER FROM STACK
    ; BRANCH IF NO CARRY
    BCC CPUMATHDIV32BITTO16BITGOODRT      
    LDX 5,S         ; POINT TO LOWER DIVIDEND/QUOTIENT
    LDB 2,s         ; GET LENGTH OF OPERANDS IN BYTES

CPUMATHDIV32BITTO16BITLASTSH
    ROL ,X+         ; SHIFT BYTE OF QUOTIENT
    DECB            ; CONTINUE THROUGH ALL BYTES
    BNE CPUMATHDIV32BITTO16BITLASTSH      ; CLEAR CARRY TO INDICATE NO ERRORS

CPUMATHDIV32BITTO16BITGOODRT
    ANDCC #$FE             ; CLEAR CARRY - NO DIVIDE-BY-ZERO ERROR

; REMOVE PARAMETERS FROM STACK AND EXIT
CPUMATHDIV32BITTO16BITDVEXIT
    LDX CPUMATHDIV32BITTO16BITHDEPTR
    LDU ,S
    LEAS 7,S
    JMP ,U

    ; DATA
CPUMATHDIV32BITTO16BITHDEPTR      RZB 2
CPUMATHDIV32BITTO16BITDIFPTR      RZB 2
CPUMATHDIV32BITTO16BITHIDE1       RZB 4
CPUMATHDIV32BITTO16BITHIDE2       RZB 4

CPUMATHDIV32BITTO16DIVISOR          RZB 4
CPUMATHDIV32BITTO16DIVIDEND         RZB 4
